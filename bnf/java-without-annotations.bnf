

# http://cui.unige.ch/isi/bnf/JAVA/BNFindex.html
start = compilation_unit

# TODO:
character : "based on the unicode character set"
decimal_digits 
      ::= 
      "0..9" { "0..9" }
doc_comment 
      ::= "/**" "... text ..." "*/"
exponent_part 
      ::= 
      "e" [ "+" | "-" ] decimal_digits
float_literal 
      ::= 
      ( decimal_digits "." [ decimal_digits ] [ exponent_part ] [ float_type_suffix ] ) 
      | ( "." decimal_digits [ exponent_part ] [ float_type_suffix ] ) 
      | ( decimal_digits [ exponent_part ] [ float_type_suffix ] ) 
float_type_suffix 
      ::= 
      "f" | "d" 
identifier 
      ::= "a..z,$,_" { "a..z,$,_,0..9,unicode character over 00C0" } 
integer_literal 
      ::= 
      ( ( "1..9" { "0..9" } ) 
      | { "0..7" } 
      | ( "0" "x" "0..9a..f" { "0..9a..f" } ) ) 
      [ "l" ]

string 
      ::= "''" { character } "''" 

# Non-terminal
####################################################################

arglist
	= [ expression ... "," ]

binary_bit_operator
	= ">>="
	| "<<"
	| ">>"
	| ">>>"

lhs_expression = expression
rhs_expression = expression

bit_expression
	= ( "~" expression )
	| ( lhs_expression binary_bit_operator rhs_expression )

casting_expression
	= "(" type ")" expression

class_declaration :=
	{ modifier } "class" identifier
	[ "extends" class_name ]
	[ "implements" { interface_name ...  "," } ]
	"{" { field_declaration } "}"

class_name :=
      identifier
      | ( package_name "." identifier )

compilation_unit :=
	[ package_statement ]
    [ import_statement ... ]
    [ type_declaration ... ]

constructor_declaration ::=
	[ modifier ... ] identifier "(" [ parameter_list ] ")"
	statement_block

creating_expression ::=
	"new"
	(
		( class_name "(" [ arglist ] ")" )
      | ( type_specifier [ "[" expression "]" ] [ "[" "]" ] )
      | ( "(" expression ")" )
	)

do_statement 
      ::= 
      "do" statement "while" "(" expression ")" ";"

expression 
      ::= 
      numeric_expression 
      | testing_expression 
      | logical_expression 
      | string_expression 
      | bit_expression 
      | casting_expression 
      | creating_expression 
      | literal_expression 
      | "null" 
      | "super" 
      | "this" 
      | identifier 
      | ( "(" expression ")" ) 
      | ( expression 
      ( ( "(" [ arglist ] ")" ) 
      | ( "[" expression "]" ) 
      | ( "." expression ) 
      | ( "," expression ) 
      | ( "instanceof" ( class_name | interface_name ) ) 
      ) ) 

field_declaration 
      ::= 
      ( [ doc_comment ] ( method_declaration 
      | constructor_declaration 
      | variable_declaration ) ) 
      | static_initializer 
      | ";" 

for_statement 
      ::= 
      "for" "(" ( variable_declaration | ( expression ";" ) | ";" ) 
      [ expression ] ";" 
      [ expression ] ";" 
      ")" statement 

then_statement := statement
else_statement := statement

if_statement 
      ::= 
      "if" "(" expression ")" then_statement [ "else" else_statement ]

import_statement 
      ::= 
      "import" ( ( package_name "." "*" ";" ) 
      | ( class_name | interface_name ) ) ";"

interface_declaration 
      ::= 
      { modifier } "interface" identifier 
      [ "extends" interface_name { "," interface_name } ] 
      "{" { field_declaration } "}"

interface_name 
      ::= 
      identifier 
      | ( package_name "." identifier ) 

literal_expression 
      ::= 
      integer_literal 
      | float_literal 
      | string 
      | character

logical_expression 
      ::= 
      ( "!" expression ) 
      | ( expression 
      ( "ampersand" 
      | "ampersand=" 
      | "|" 
      | "|=" 
      | "^" 
      | "^=" 
      | ( "ampersand" "ampersand" ) 
      | "||=" 
      | "%" 
      | "%=" ) 
      expression ) 
      | ( expression "?" expression ":" expression ) 
      | "true" 
      | "false"

method_declaration 
      ::= 
      { modifier } type identifier 
      "(" [ parameter_list ] ")" { "[" "]" } 
      ( statement_block | ";" )

modifier 
      ::= 
      "public" 
      | "private" 
      | "protected" 
      | "static" 
      | "final" 
      | "native" 
      | "synchronized" 
      | "abstract" 
      | "threadsafe" 
      | "transient"

numeric_expression 
      ::= 
      ( ( "-" 
      | "++" 
      | "--" ) 
      expression ) 
      | ( expression 
      ( "++" 
      | "--" ) ) 
      | ( expression 
      ( "+" 
      | "+=" 
      | "-" 
      | "-=" 
      | "*" 
      | "*=" 
      | "/" 
      | "/=" 
      | "%" 
      | "%=" ) 
      expression )

package_name 
      ::= 
      identifier 
      | ( package_name "." identifier )

package_statement 
      ::= 
      "package" package_name ";"

parameter 
      ::= 
      type identifier { "[" "]" }

parameter_list 
      ::= 
      parameter { "," parameter }

statement 
      ::= 
      variable_declaration 
      | ( expression ";" ) 
      | ( statement_block ) 
      | ( if_statement ) 
      | ( do_statement ) 
      | ( while_statement ) 
      | ( for_statement ) 
      | ( try_statement ) 
      | ( switch_statement ) 
      | ( "synchronized" "(" expression ")" statement ) 
      | ( "return" [ expression ] ";" ) 
      | ( "throw" expression ";" ) 
      | ( identifier ":" statement ) 
      | ( "break" [ identifier ] ";" ) 
      | ( "continue" [ identifier ] ";" ) 
      | ( ";" )

statement_block 
      ::= "{" { statement } "}"

static_initializer 
      ::= 
      "static" statement_block

string_expression 
      ::= ( expression 
      ( "+" 
      | "+=" ) 
      expression )

switch_statement 
      ::= 
      "switch" "(" expression ")" "{" 
      { ( "case" expression ":" ) 
      | ( "default" ":" ) 
      | statement } 
      "}"

testing_expression 
      ::= 
      ( expression 
      ( ">" 
      | "<" 
      | ">=" 
      | "<=" 
      | "==" 
      | "!=" ) 
      expression )

try_statement 
      ::= 
      "try" statement 
      { "catch" "(" parameter ")" statement } 
      [ "finally" statement ]

type 
      ::= 
      type_specifier { "[" "]" }

type_declaration 
      ::= 
      [ doc_comment ] ( class_declaration | interface_declaration ) ";"

type_specifier 
      ::= 
      "boolean" 
      | "byte" 
      | "char" 
      | "short" 
      | "int" 
      | "float" 
      | "long" 
      | "double" 
      | class_name 
      | interface_name 


variable_declaration 
      ::= 
      { modifier } type variable_declarator 
      { "," variable_declarator } ";"


variable_declarator 
      ::= 
      identifier { "[" "]" } [ "=" variable_initializer ]

variable_initializer 
      ::= 
      expression 
      | ( "{" [ variable_initializer 
      { "," variable_initializer } [ "," ] ] "}" )

while_statement 
      ::= 
      "while" "(" expression ")" statement

