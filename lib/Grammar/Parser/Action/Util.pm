
use Syntax::Construct 1.008 qw[ package-version package-block ];

use v5.14;
use strict;
use warnings;

package Grammar::Parser::Action::Util v1.0.0 {
	use parent 'Exporter::Tiny';

	use List::Util   qw[ first ];
	use Ref::Util    qw[ is_plain_arrayref is_plain_hashref is_coderef ];
	use Scalar::Util qw[ blessed ];
	use Sub::Install qw[ install_sub ];
	use Sub::Name    qw[ subname ];

	my %templates = map +($_ => __PACKAGE__->can ($_)), (
		'alias',
		'alias_merge',
		'default',
		'literal',
		'literal_value',
		'list',
		'merge',
		'pass_through',
		'symbol',
		'value',
	);
	our $DEFAULT_PREFIX = 'rule_';

	our @EXPORT_OK = (
		'rule',
		'action_name',
	);

use namespace::clean;

sub alias {
	my (undef, $name, @list) = @_;
	my $value = first { is_plain_hashref $_ } @list;

	return unless $value;
	return +{ $name => values %$value };
}

sub alias_merge {
	my (undef, $name, @list) = @_;
	my ($value, @rest) = grep { is_plain_hashref $_ } @list;

	return unless $value;
	return +{ $name => values %$value, map %$_, reverse @rest };
}

sub default {
	my (undef, $name, @list) = @_;

	return +{ $name => { map %$_, grep { is_plain_hashref $_ } reverse @list }};
}

sub literal {
	return;
}

sub literal_value {
	my (undef, $name, @values) = @_;

	my $value = first { blessed $_ } @values;

	$value = $value->[0] if is_plain_arrayref $value;
	$value = $value->value if blessed $value;
	$value = undef if is_plain_hashref $value;
	$value //= $name;

	return +{ $name => $value };
}

sub list {
	my (undef, $name, @list) = @_;

	return +{ $name => [
		map exists $_->{$name} ? @{ $_->{$name} } : $_, grep { is_plain_hashref $_ } @list
	] };
}

sub merge {
	my (undef, $name, @list) = @_;

	return +{ map %$_, reverse grep { is_plain_hashref $_ } @list };
}

sub pass_through {
	my (undef, $name, @def) = @_;

	my $retval = first { is_plain_hashref $_ } @def;
	$retval //= $def[0];

	return $retval;
}

sub symbol {
	my (undef, $name) = @_;

	return +{ $name => $name };
}

sub value {
	my (undef, $name, @list) = @_;

	my $value = first { is_plain_hashref $_ } @list;

	return (values %$value)[0];
}

sub generate_rule_handler {
	my ($name, $type, @params) = @_;

	die "Method $type not defined\n"
		unless exists $templates{$type};

	return sub { $templates->{$type}->(@_) };
}

sub generate_action_name {
	my $prefix = $PREFIX // '';
	return sub {
		my ($name) = @_;

		return "${prefix}${name}";
	};
}

sub install_action_name {
	my ($name) = @_;
	my $caller = caller;

	Sub::Install::install_sub ({
		code => generate_action_name,
		into => $caller,
		as   => $name,
	});

	();
}

sub rule {
	my ($name, $code, @params) = @_;

	my $prefix = $PREFIX // '';
	$prefix = '' if $name eq 'AUTOLOAD';
	my $as = "${prefix}${name}";
	my $caller = caller;

	unless (is_coderef $code) {
		$code = generate_rule_handler ($name, $code, @params);
		Sub::Name::subname "${caller}::${as}" => $code;
	}

	Sub::Install::install_sub ({
		code => $code,
		into => $caller,
		as   => $as,
	});

	();
}

1;

__END__

=encoding utf8

=head1 NAME

Grammar::Parser::Action::Util - Tools to define rule actions

=head1 USAGE

	use Grammar::Parser::Action::Util qw( rule );

	rule identifier => 'value';
	rule table_name => 'alias';

=head1 DESCRIPTION

TODO: better explanation of intent

L<< Grammar::Parser >> provides default rule actions to build unified AST.

Rule-action binding is done automagically by rule name.

=head1 EXPORTABLE FUNCTIONS

=head2 generate_rule_handler ($name, $type)

Generate coderef according C<< $type >> handling rule C<< $name >>.
See L<< /"RULE TYPES" >> bellow.

=head2 generate_action_name ($name)

Generate action name generator.

=head2 install_action_name ($name)

Installs action name function (generated by L<< /"generate_action_name" >>) into caller's namespace.

=head2 rule ($name, $code or $type)

Install C<< $code >> or C<< $type >> coderef generated by L<< /gen_rule_handler >>
as C<<rule_$name >> function in caller package.

=head1 RULE TYPES

All types expect that any rule handler returns hashref or scalar, where hashref
contains key with rule name.

=over

=item alias

Treats rule as an alias for other rule. Takes first hashref.
Expects parent action returning hashref with one key.

	# BNF
	table_name := identifier

	# action handler
	rule table_name => 'alias';

	# input
	{ identifier => identifier value }

	# result of table_name rule
	{ table_name => identifier value }

=item alias_merge

Similar to L<< /alias >> but also merges other hashrefs into result value.

	# BNF
	precision := integer ',' scale

	# action handler
	rule precision => 'alias_merge';

	# input
	{ integer => integer value }
	{ scale => scale value }

	# result
	{ precision => integer value, scale => scale value }

=item default

Default handling, merges all rules into single hashref as value of rule named key

	# BNF
	precision := integer ',' scale

	# action handler
	rule precision => 'default';

	# input
	{ integer => integer value }
	{ scale => scale value }

	# result
	{ precision => { integer => integer value, scale => scale value } }

=item devel_dump

Development action, will just dump data on STDOUT

=item literal

Literals are ignored by default.

	# BNF
	UNIQUE := qr/UNIQUE/i

	# rule
	rule UNIQUE => 'literal';

=item literal_value

Takes value matched by literal symbol as value.
If value is not provided rule name is used.

	# BNF
	idenfifier := qr/(\w+)/

	# rule
	rule idenfifier => 'literal_value';

	# result
	{ idenfier => 'whatever matched by (\w+)' }

=item list

Returns hashref where value is a list of hashrefs, elements of repeating rule

	# BNF
	sql_script := { sql_command }

	# rule
	rule sql_script => 'list';

	# result
	{ sql_script => [ { sql_command => ... }, { ... }, ... ] }

=item merge

Merges all results into single hashref

	# BNF
	create_index := CREATE unique INDEX index_name ON table_name

	# rule
	rule create_index => 'merge';

	# result
	{
		create_index => {
			unique => 'unique',
			index_name => ...,
			table_name => ...,
		}
	}

=item merge_value

Similar to merge but returns only value

	# BNF
	create_index := CREATE unique INDEX index_name ON table_name

	# rule
	rule create_index => 'merge_value';

	# result
	{
		unique => 'unique',
		index_name => ...,
		table_name => ...,
	}

=item pass_through

Takes first hashref or first value in case there is no hashref.

	# BNF
	sql_command := create_table | create_index

	# rule
	rule sql_command => 'pass_through';

	# result
	{ create_table => ... } or { create_index => ... }

=item symbol

Similar to literal treating literals as flags (exists/not exists in resulting hashref)

	# BNF
	unique := qr/\b UNIQUE \b/ix

	# rule
	rule unique => 'symbol',

	# result
	{ unique => 'unique' }

=item value

Returns value of first hashref (expecting it contains only one key).

=back

=head1 AUTHOR

Branislav Zahradn√≠k <barney@cpan.org>

=head1 COPYRIGHT

This file if part of L<< Grammar::Parser >>.
It can be distributed and/or modified under Artistic license 2.0

=cut
